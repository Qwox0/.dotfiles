#!/usr/bin/env bash

set -e

script_dir="$(dirname "$(readlink -f "$0")")"

info() {
    echo -e "\e[92;1m+++ WATCH:\e[0m $1"
}

warn() {
    echo -e "\e[93;1m+++ WATCH: WARN:\e[0m $1"
}

error() {
    echo -e "\e[91;1m+++ WATCH: ERROR:\e[0m $1" >&2
    if [ ! -z "$2" ]; then exit ${2:-1}; fi
}

clear=false
respect_gitignore=true
ignore_patterns=("target" ".git")

POSITIONAL_ARGS=()
while [[ $# -gt 0 ]]; do
    case $1 in
        --) shift; POSITIONAL_ARGS+=("$@"); break;;
        -c|--clear) clear=true; shift;;
        --no-gitignore) respect_gitignore=false; shift;;
        -i|--ignore)
            ignore_patterns+=("$2")
            shift; shift;;
        -*|--*) error "Unknown option $1" 1;;
        *) POSITIONAL_ARGS+=("$1"); shift;;
    esac
done
set -- "${POSITIONAL_ARGS[@]}"
unset POSITIONAL_ARGS

path="."
command="$@"
print_all_events=true

run_command() {
    info "Executing \`$command\`"
    eval $command || error "Command exited with $?"
    info "Command finished (code: $?)"
}

respect_gitignore_text=""
[ "$respect_gitignore" = true ] && respect_gitignore_text="content of .gitignore; "

info "Watching '$path'"
info "Ignoring: $respect_gitignore_text$ignore_patterns"

if [ -z "$(which inotifywait)" ]; then error "inotifywait not installed."; fi

run_command
printf "\n"

buffer_timeout=0.1

inotifywait --recursive --monitor --format "%w%f" --event modify,move,create,delete $path |
    while read -r changed; do
        # echo is needed otherwise `timeout` never quits
        buffered_events="$(echo "$changed"$'\n'"$(timeout $buffer_timeout cat)")"

        sep=", "
        changed_files_out="$(echo "$buffered_events" | sed 's/~$//' | sort --unique |
            while read file; do
                if git check-ignore "$file" >/dev/null 2>&1; then continue; fi
                simple_file_path="$(realpath -m --relative-to="$path" "$file")"
                for ignore in "${ignore_patterns[@]}"; do
                    if [[ "$simple_file_path" = $ignore ]]; then continue 2; fi
                done
                printf "$sep$file"
            done
        )"
        changed_files_out="${changed_files_out:${#sep}}"

        if [ -z "$changed_files_out" ]; then continue; fi

        if [ "$print_all_events" = false ]; then
            max_width=$(($(tput cols) - 32))
            if [[ ${#changed_files_out} -gt $max_width ]] then
                changed_files_out="$(sed 's/^\(.*\),[^,]*$/\1, .../' <<< "${changed_files_out:0:max_width}")"
            fi
        fi

        if [ "$clear" = true ]; then clear; fi

        info "file(s) changed: $changed_files_out"
        run_command
    done
