#!/usr/bin/env bash

set -e

script_dir="$(dirname "$(readlink -f "$0")")"

info() {
    echo -e "\e[92;1m+++ WATCH:\e[0m $1"
}

warn() {
    echo -e "\e[93;1m+++ WATCH: WARN:\e[0m $1"
}

error() {
    echo -e "\e[91;1m+++ WATCH: ERROR:\e[0m $1" >&2
    if [ ! -z "$2" ]; then exit ${2:-1}; fi
}

#set -x
#watchexec --no-project-ignore --ignore "\"target\"" -- $@

path="."
command="$@"
ignore="@./target @./.git"
respect_gitignore=true
print_all_changed_file=true

run_command() {
    eval $command || error "Command exited with $?"
}

respect_gitignore_text=""
[ "$respect_gitignore" = true ] && respect_gitignore_text="content of .gitignore; "

info "Watching '$path'"
info "Ignoring: $respect_gitignore_text$ignore"
info "Executing \`$command\` on change"

if [ -z "$(which inotifywait)" ]; then error "inotifywait not installed."; fi

run_command
printf "\n"

buffer_timeout=0.1

inotifywait --recursive --monitor $ignore --format "%w%f" --event modify,move,create,delete $path |
    while read -r changed; do
        # echo is needed otherwise `timeout` never quits
        buffered_events="$(echo "$changed"$'\n'"$(timeout $buffer_timeout cat)")"

        sep=", "
        changed_files_out="$(echo "$buffered_events" | sed 's/~$//' | sort --unique |
            while read file; do
                if ! git check-ignore "$file" >/dev/null 2>&1; then printf "$sep$file"; fi
            done
        )"
        changed_files_out="${changed_files_out:${#sep}}"

        if [ -z "$changed_files_out" ]; then continue; fi

        if [ "$print_all_changed_file" = false ]; then
            max_width=$(($(tput cols) - 32))
            if [[ ${#changed_files_out} -gt $max_width ]] then
                changed_files_out="$(sed 's/^\(.*\),[^,]*$/\1, .../' <<< "${changed_files_out:0:max_width}")"
            fi
        fi

        info "file(s) changed: $changed_files_out"
        run_command
    done
